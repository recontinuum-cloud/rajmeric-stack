# ═══════════════════════════════════════════════════════════════
#  RAJMERIC CORE-X — COMPLETE DEVOPS INFRASTRUCTURE
#  Terraform + Docker + Kubernetes + CI/CD
# ═══════════════════════════════════════════════════════════════

# ─── .github/workflows/deploy.yml ──────────────────────────────
name: RAJMERIC CORE-X — Deploy Pipeline
on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  AWS_REGION: ap-south-1
  ECR_REPOSITORY: rajmeric-api
  EKS_CLUSTER: rajmeric-production

jobs:
  # ── 1. Quality Gates ─────────────────────────────────────────
  quality:
    name: Code Quality & Security
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: "22", cache: "npm" }
      - run: npm ci
      - name: TypeScript Check
        run: npm run type-check
      - name: ESLint
        run: npm run lint
      - name: Unit Tests
        run: npm run test:unit -- --coverage
      - name: Coverage Gate (>80%)
        run: npm run test:coverage-check
      - name: Security Scan (Snyk)
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
      - name: SAST (CodeQL)
        uses: github/codeql-action/analyze@v3

  # ── 2. Integration Tests ─────────────────────────────────────
  integration:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: quality
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_PASSWORD: test_password
          POSTGRES_DB: rajmeric_test
        options: --health-cmd pg_isready
      redis:
        image: redis:7-alpine
        options: --health-cmd "redis-cli ping"
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: "22", cache: "npm" }
      - run: npm ci
      - run: npm run test:integration
        env:
          DATABASE_URL: postgresql://postgres:test_password@localhost/rajmeric_test
          REDIS_URL: redis://localhost:6379

  # ── 3. Build & Push Docker Image ─────────────────────────────
  build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: [quality, integration]
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
    steps:
      - uses: actions/checkout@v4
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      - name: Login to ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      - name: Build & Push
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NODE_ENV=production
            BUILD_VERSION=${{ github.sha }}

  # ── 4. Deploy to Staging ─────────────────────────────────────
  staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: build
    environment: staging
    steps:
      - uses: actions/checkout@v4
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      - name: Update Kubernetes Deployment
        run: |
          aws eks update-kubeconfig --name $EKS_CLUSTER-staging
          kubectl set image deployment/rajmeric-api \
            api=${{ needs.build.outputs.image-tag }} \
            --namespace staging
          kubectl rollout status deployment/rajmeric-api --namespace staging --timeout=5m
      - name: Run Smoke Tests
        run: npm run test:smoke -- --env=staging

  # ── 5. Production Deploy (Canary) ────────────────────────────
  production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: staging
    environment: production
    if: github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v4
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      - name: Canary Deploy (10% traffic)
        run: |
          aws eks update-kubeconfig --name $EKS_CLUSTER
          kubectl set image deployment/rajmeric-api-canary \
            api=${{ needs.build.outputs.image-tag }} \
            --namespace production
          kubectl rollout status deployment/rajmeric-api-canary --timeout=5m
      - name: Monitor Canary (10 minutes)
        run: |
          sleep 600
          ERROR_RATE=$(curl -s "${{ secrets.DATADOG_API }}/query?query=error_rate{env:production,version:canary}" | jq '.series[0].pointlist[-1][1]')
          if (( $(echo "$ERROR_RATE > 0.01" | bc -l) )); then
            echo "ERROR: Error rate $ERROR_RATE exceeds 1% threshold — rolling back"
            kubectl rollout undo deployment/rajmeric-api-canary --namespace production
            exit 1
          fi
          echo "Canary healthy — proceeding to full rollout"
      - name: Full Production Rollout
        run: |
          kubectl set image deployment/rajmeric-api \
            api=${{ needs.build.outputs.image-tag }} \
            --namespace production
          kubectl rollout status deployment/rajmeric-api --timeout=10m

---
# ─── Dockerfile ─────────────────────────────────────────────────
# Multi-stage build for minimal production image

FROM node:22-alpine AS deps
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

FROM node:22-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM node:22-alpine AS runner
WORKDIR /app
ENV NODE_ENV=production

# Create non-root user (security hardening)
RUN addgroup --system --gid 1001 rajmeric && \
    adduser --system --uid 1001 apiuser

# Copy only what's needed
COPY --from=deps /app/node_modules ./node_modules
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/package*.json ./

# Switch to non-root user
USER apiuser

EXPOSE 4000

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=30s --retries=3 \
  CMD node -e "require('http').get('http://localhost:4000/health', (r) => process.exit(r.statusCode === 200 ? 0 : 1))"

CMD ["node", "dist/server.js"]

---
# ─── kubernetes/production/deployment.yaml ──────────────────────
apiVersion: apps/v1
kind: Deployment
metadata:
  name: rajmeric-api
  namespace: production
  labels:
    app: rajmeric-api
    version: "2.0.0"
spec:
  replicas: 3
  selector:
    matchLabels:
      app: rajmeric-api
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  template:
    metadata:
      labels:
        app: rajmeric-api
    spec:
      serviceAccountName: rajmeric-api
      containers:
      - name: api
        image: ECR_REGISTRY/rajmeric-api:LATEST
        ports:
        - containerPort: 4000
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "1000m"
        env:
        - name: NODE_ENV
          value: "production"
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: rajmeric-secrets
              key: database-url
        - name: REDIS_PASSWORD
          valueFrom:
            secretKeyRef:
              name: rajmeric-secrets
              key: redis-password
        - name: OPENAI_API_KEY
          valueFrom:
            secretKeyRef:
              name: rajmeric-secrets
              key: openai-api-key
        livenessProbe:
          httpGet:
            path: /health
            port: 4000
          initialDelaySeconds: 30
          periodSeconds: 10
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /ready
            port: 4000
          initialDelaySeconds: 10
          periodSeconds: 5
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              labelSelector:
                matchExpressions:
                - key: app
                  operator: In
                  values: ["rajmeric-api"]
              topologyKey: kubernetes.io/hostname

---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: rajmeric-api-hpa
  namespace: production
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: rajmeric-api
  minReplicas: 3
  maxReplicas: 50
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80

---
# ─── terraform/main.tf ──────────────────────────────────────────
# AWS Infrastructure as Code

terraform {
  required_providers {
    aws = { source = "hashicorp/aws", version = "~> 5.0" }
  }
  backend "s3" {
    bucket = "rajmeric-terraform-state"
    key    = "production/terraform.tfstate"
    region = "ap-south-1"
    encrypt = true
    dynamodb_table = "rajmeric-terraform-locks"
  }
}

provider "aws" {
  region = var.aws_region
  default_tags {
    tags = {
      Project     = "RAJMERIC-CORE-X"
      Environment = var.environment
      ManagedBy   = "Terraform"
    }
  }
}

# VPC — isolated network
module "vpc" {
  source = "terraform-aws-modules/vpc/aws"
  name   = "rajmeric-vpc"
  cidr   = "10.0.0.0/16"
  azs    = ["ap-south-1a", "ap-south-1b", "ap-south-1c"]
  private_subnets  = ["10.0.1.0/24", "10.0.2.0/24", "10.0.3.0/24"]
  public_subnets   = ["10.0.101.0/24", "10.0.102.0/24", "10.0.103.0/24"]
  database_subnets = ["10.0.201.0/24", "10.0.202.0/24", "10.0.203.0/24"]
  enable_nat_gateway = true
  single_nat_gateway = false  # HA: one per AZ
  enable_vpn_gateway = false
  enable_flow_log    = true  # Security auditing
}

# RDS Aurora PostgreSQL
module "rds" {
  source              = "terraform-aws-modules/rds-aurora/aws"
  name                = "rajmeric-postgres"
  engine              = "aurora-postgresql"
  engine_version      = "16.2"
  instance_class      = "db.r6g.large"
  instances           = { 1 = {}, 2 = {}, 3 = {} }  # 1 writer, 2 readers
  vpc_id              = module.vpc.vpc_id
  db_subnet_group_name = module.vpc.database_subnet_group
  storage_encrypted   = true
  kms_key_id          = aws_kms_key.rds.arn
  deletion_protection = true
  backup_retention_period = 30  # 30 days
  preferred_backup_window = "02:00-03:00"
  monitoring_interval = 60
  performance_insights_enabled = true
  performance_insights_retention_period = 731  # 2 years
}

# ElastiCache Redis Cluster
module "redis" {
  source                = "terraform-aws-modules/elasticache/aws"
  cluster_id            = "rajmeric-redis"
  engine                = "redis"
  node_type             = "cache.r7g.large"
  num_cache_nodes       = 6  # 3 primary + 3 replica
  automatic_failover    = true
  multi_az_enabled      = true
  at_rest_encryption    = true
  transit_encryption    = true
  auth_token            = var.redis_auth_token
  snapshot_retention_limit = 7
}

# EKS Kubernetes Cluster
module "eks" {
  source          = "terraform-aws-modules/eks/aws"
  cluster_name    = "rajmeric-production"
  cluster_version = "1.30"
  vpc_id          = module.vpc.vpc_id
  subnet_ids      = module.vpc.private_subnets
  cluster_encryption_config = {
    resources = ["secrets"]
    provider_key_arn = aws_kms_key.eks.arn
  }
  node_security_group_additional_rules = {
    ingress_self_all = {
      from_port   = 0
      to_port     = 0
      protocol    = "-1"
      type        = "ingress"
      self        = true
    }
  }
  managed_node_groups = {
    on_demand = {
      name           = "on-demand"
      instance_types = ["m6i.xlarge"]
      min_size       = 3
      desired_size   = 3
      max_size       = 10
      capacity_type  = "ON_DEMAND"
      disk_size      = 50
    }
    spot = {
      name           = "spot"
      instance_types = ["m6i.xlarge", "m5.xlarge", "m5a.xlarge"]
      min_size       = 0
      desired_size   = 2
      max_size       = 30
      capacity_type  = "SPOT"
    }
  }
}

# CloudFront CDN
resource "aws_cloudfront_distribution" "cdn" {
  origin {
    domain_name = aws_s3_bucket.assets.bucket_regional_domain_name
    origin_id   = "S3-rajmeric-assets"
    s3_origin_config {
      origin_access_identity = aws_cloudfront_origin_access_identity.oai.cloudfront_access_identity_path
    }
  }
  enabled             = true
  is_ipv6_enabled     = true
  default_root_object = "index.html"
  aliases             = ["cdn.rajmeric.com"]
  
  default_cache_behavior {
    allowed_methods        = ["GET", "HEAD", "OPTIONS"]
    cached_methods         = ["GET", "HEAD"]
    target_origin_id       = "S3-rajmeric-assets"
    viewer_protocol_policy = "redirect-to-https"
    compress               = true
    min_ttl     = 0
    default_ttl = 86400    # 1 day
    max_ttl     = 31536000 # 1 year
  }
  
  restrictions {
    geo_restriction { restriction_type = "none" }
  }
  
  viewer_certificate {
    acm_certificate_arn = aws_acm_certificate.cdn.arn
    ssl_support_method  = "sni-only"
    minimum_protocol_version = "TLSv1.2_2021"
  }
  
  web_acl_id = aws_wafv2_web_acl.main.arn
}

# KMS Keys
resource "aws_kms_key" "pii" {
  description             = "RAJMERIC — PII Data Encryption Key"
  deletion_window_in_days = 30
  enable_key_rotation     = true  # Auto-rotate every year
  multi_region            = true  # Cross-region disaster recovery
  policy                  = data.aws_iam_policy_document.kms_pii.json
}

# WAF Rules
resource "aws_wafv2_web_acl" "main" {
  name  = "rajmeric-waf"
  scope = "CLOUDFRONT"
  
  default_action { allow {} }
  
  rule {
    name     = "AWSManagedRulesCommonRuleSet"
    priority = 1
    override_action { none {} }
    statement {
      managed_rule_group_statement {
        name        = "AWSManagedRulesCommonRuleSet"
        vendor_name = "AWS"
      }
    }
    visibility_config {
      cloudwatch_metrics_enabled = true
      metric_name                = "CommonRuleSetMetric"
      sampled_requests_enabled   = true
    }
  }
  
  rule {
    name     = "RateLimitRule"
    priority = 2
    action { block {} }
    statement {
      rate_based_statement {
        limit              = 2000  # Per 5 minutes per IP
        aggregate_key_type = "IP"
      }
    }
    visibility_config {
      cloudwatch_metrics_enabled = true
      metric_name                = "RateLimitMetric"
      sampled_requests_enabled   = true
    }
  }
}

# Outputs
output "cluster_endpoint" { value = module.eks.cluster_endpoint }
output "rds_endpoint"     { value = module.rds.cluster_endpoint }
output "redis_endpoint"   { value = module.redis.primary_endpoint_address }
output "cdn_domain"       { value = aws_cloudfront_distribution.cdn.domain_name }
